{
open Feint.Parser
open Feint.LexerUtil
}

let ws = [' ' '\t']+
let nl = "\r\n" | '\n'

let ascii_lower = ['a' - 'z']
let ascii_lower_digits = ['a' - 'z' '0' - '9']
let ascii_lower_digits_underscore = ['a' - 'z' '0' - '9' '_']

let keyword = '$'? ascii_lower+

let placeholder_ident = '_'+
let ident = ascii_lower | ascii_lower ascii_lower_digits_underscore* ascii_lower_digits
let special_ident = '$' ident

let dec = ['0' - '9']
let bin = ['0' - '1']
let oct = ['0' - '7']
let hex = ['0' - '9' 'a' - 'f' 'A' - 'F']

let int_10 = '0' | ['1' - '9'] ('_'? dec+)*
let int_02 = "0b" bin+
let int_08 = "0o" oct+
let int_16 = "0x" hex+
let int = ['+' '-']? int_10 | int_02 | int_08 | int_16

let float =
  dec+ '.' dec+
  | dec+ ('.' dec+) ['e' 'E'] ['+' '-']? dec+

let operator =
  // Unary
  '!'
  | "!!"
  // Binary
  | '^'
  | '*'
  | '/'
  | "//"
  | '%'
  | '+'
  | '-'
  // Short Circuit
  | "&&"
  | "||"
  | "??"
  // Compare
  | "$$"
  | "$!"
  | "==="
  | "!=="
  | "=="
  | "!="
  | "<"
  | "<="
  | ">"
  | ">="
  // In Place
  | "*="
  | "/="
  | "+="
  | "-="
  // Assignment
  | '='
  | "<-"
  // Other
  | '.'
  | ','

rule read = parse
  // Whitespace
  | ws { read lexbuf }
  | nl { new_line lexbuf; NL }
  // Comments
  | ('#' ([^ '\n']*) ('\n' | eof)) {
      new_line lexbuf;
      COMMENT (lexeme lexbuf)
    }
  | ("//" ([^ '\n']*) ('\n' | eof)) {
      new_line lexbuf;
      DOC_COMMENT (lexeme lexbuf)
    }
  // Scopes
  | "->" ws* nl { new_line lexbuf; SCOPE_START }
  | "->" { INLINE_SCOPE_START }
  | "=>" ws* nl { new_line lexbuf; FUNC_START }
  | "=>" { INLINE_FUNC_START }
  // Groupings
  | '(' { LPAREN }
  | ')' { RPAREN }
  | '[' { LBRACE }
  | ']' { RBRACE }
  | '{' { LBRACKET }
  | '}' { RBRACKET }
  // Keywords
  | keyword { get_keyword (lexeme lexbuf) }
  // Types
  | int { INT (bigint.Parse (lexeme lexbuf)) }
  | float { FLOAT (float (lexeme lexbuf)) }
  | '"' { read_double_quoted_string lexbuf }
  | '\'' { read_single_quoted_string lexbuf }
  // Identifiers
  | ident { IDENT (lexeme lexbuf) }
  | special_ident { SPECIAL_IDENT (lexeme lexbuf) }
  // Operators
  | operator { operators.[lexeme lexbuf] }
  | eof { EOF }
  | _ { raise_err $"Unexpected character in input stream: {lexeme lexbuf}" }

and read_double_quoted_string = parse
  | eof { raise_err "Unterminated string literal" }
  | ('\\' _ | [^ '\\'])* '"' { STR (process_str lexbuf) }
  | ('\\' _ | [^ '\\'])* { raise_err "Unterminated string literal" }

and read_single_quoted_string = parse
  | ('\\' _ | [^ '\\'])* '\'' { STR (process_str lexbuf) }
  | ('\\' _ | [^ '\\'])* { raise_err "Unterminated string literal" }
